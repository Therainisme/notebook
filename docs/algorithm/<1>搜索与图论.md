# 搜索与图论

## Dijkstra 

::: tip 关于它
它用于求一个顶点到其余顶点的最短路径长，时间复杂度$O^2$
:::

### 问题

给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出 $1$ 号点到 $n$ 号点的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，则输出 $-1$。

**输入格式**

第一行包含整数 $n$ 和 $m$。

接下来 $m$ 行每行包含三个整数 $x$,$y$,$z$，表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。

### 思路

1. 存储方式

图中有重边和自环，所以它是一个稠密图。稠密图推荐使用邻接矩阵来存储。

为了存储顶点 $1$ 到其余顶点的最短路径长，可以一数组记录其到达某个顶点的最短路径长。

如果一个顶点确定了最短路，那么就不再考虑，设一标记数组，标记该顶点是否已经确定了最短路。

```cpp
int g[a][b] = c; // 记录着顶点a到顶点b的最短路径长c
int dist[x] = l; // 记录着顶点0到x的最短路径长l
int st[x] = 0 or 1; //记录这顶点x，是否已经确认了0到x的最短路
```

2. 算法主体

* 每一次循环选择一个已经确定最短路的顶点作为更新点
* 从该顶点出发，更新它能走到的顶点的最短路径
* 该顶点更新结束后，选择在结束更新的顶点中选择最短的那个点作为下一个更新点，重复第二个步骤，直到所有顶点的最短路确定。

### 代码 

ACWING: [Dijkstra求最短路 I](https://www.acwing.com/problem/content/description/851/)

```cpp {17-30}
#include <iostream>
#include <cstring>

using namespace std;

const int N = 510;
int g[N][N];
int dist[N];
int st[N];
int n, m;

void dijkstra() {
    memset(dist, 0x3f, sizeof dist); // 将最短路数组初始化为无穷大
    int now = 1; // 第一个顶点是1
    dist[now] = 0; // 它到自身的距离是0
    st[now] = 1; // 顶点1已经找到了最短路
    for (int i = 1; i <= n - 1; ++ i) { // n个点，只需要遍历n-1次
        // next是顶点now想要走去的点
        for (int next = 1; next <= n; ++ next) {
            dist[next] = min(dist[next], dist[now] + g[now][next]);
        }
        // 现在开始选取下一个更新点now
        now = -1;
        for (int j = 1; j <= n; ++ j) {
            if (st[j] == 0 && (now == -1 || dist[j] < dist[now])) {
                now = j;
            }
        }
        // 选中了更新点，那么这个点就确认了最短路
        st[now] = 1;
    }
}

int main (){
    cin >> n >> m;
    memset(g,0x3f,sizeof g); // 将临界矩阵初始化为无穷大
    for (int i = 1; i <=m; ++ i) {
        int a, b, l;
        cin >> a >> b >> l;
        // 如果出现重边，选择两条边最小的一个即可
        // 如果出现自环，可不做处理
        g[a][b] = min(g[a][b], l); 
    }
    dijkstra();
    // 如果顶点1到顶点n的距离是无穷大
    if (dist[n] == 0x3f3f3f3f) cout << "-1";
    else cout << dist[n];
    
    return 0;
}
```

## Floyd

::: tip 关于它
它用于求任意两点间的最短路，时间复杂度$O^3$
:::

###  问题

给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环，边权可能为负数。

再给定 $k$ 个询问，每个询问包含两个整数 $x$ 和 $y$，表示查询从点 $x$ 到点 $y$ 的最短距离，如果路径不存在，则输出 impossible。

数据保证图中不存在负权回路。

### 思路

1. 存储方式

图中有重边和自环，所以它是一个稠密图。稠密图推荐使用邻接矩阵来存储。