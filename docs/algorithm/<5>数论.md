# 数论

## 试除法判定质数

::: tip 关于
一个数的因数都是成对出现的，例如12的因数有3和4，2和6

最小的那个肯定不会超过 $\sqrt{n}$ 吧

36 的因数对：$<1, 36> <2, 18> <3, 12> <4, 8> <6, 6>$

所以只需要枚举较小的那个，$i * i \le n$，但是这样在C++中会溢出，把一个 $i$ 丢到除数下就好了 
:::

```cpp
bool check(int x){
    if (x < 2) return false;
    for (int i = 2; i <= x / i; ++ i) {
        if (x % i == 0) return false;
    }
    return true;
}
```

## 分解质因数

::: tip 关于
任何一个数，都可以表示成很多个质因数相乘 $10 = 2 * 5$

注意算法得考虑到超过 $\sqrt{n}$ 的因数，否则会漏掉结果。

比如 $\sqrt{6} \approx 2.2449$ ，但它有个因数是 $3$
:::

```cpp
void divide(int x) {
    for (int i = 2; i <= x / i; ++ i) {
        if (x % i == 0) {  // 如果是质因数
            int cnt = 0;   // 求其指数 
            while(x % i == 0) {
                cnt ++;
                x /= i;
            }
            cout << i << " " << cnt << endl;
        }
    }
    // 在这里如果 x > 1,说明还剩下一个大于大于 sqrt(x) 的因数
    if (x > 1) cout << x << " " << 1 << endl;
}
```

## 试除法求所有因数

::: tip 关于
于求质因数方法大同小异，所有因数都是成对出现的，只需要枚举小的那个。

需要注意的是，像 36 / 6 = 6 ，必须得特殊判别一下，否则会将两个 6 加入到结果集中
:::

```cpp {5}
void divide (int x) {
    for (int i = 1; i <= x / i; ++ i) {
        if (x % i == 0) {
            v.push_back(i);
            if (x / i != i) v.push_back(x / i);
        }
    }
    sort(v.begin(), v.end());
}
```

## 最大公约数 & 最小公倍数

::: tip 关于
这么优美的算法不背一下吗？ `gcd(a, b)` 求的是最大公约数

最小公倍数就是 `a * b / gcd(a, b)`
:::

```cpp
int gcd(int a, int b){
    return b ? gcd(b, a % b) : a;
}
```