# 每日一题

## [1838. 最高频元素的频数](https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/)

题目的要求是，在给定的元素内，使数组齐平。例如下图是一个 [1，2，4] 的数组，当 k = 5时补齐的状态。所以答案为 3 。

![](./image/2021-07-19-15-54-38.png)

所以可以使用一个滑动窗口，在这个滑动范围之内，都会尝试去用 `k` 将数组补齐。要使用滑动窗口，必须先让它排个序！此时已经是 (`nlogn`)了。

由于排序数组了，每次枚举在区间内最大的数，会尝试用 `k` 去补齐。在滑动循环内只能由两种情况：（假设滑动区间为 `left ~ right`）

1. 尝试将区间的数向 `nums[right]` 补齐，使用的次数 `sum` **小于等于** `k`。

直接更新当前答案。

```js
// 此刻之前的元素已经与 nums[right - 1] 补齐
// 所以现在只需要把之间的差补齐
nums += (nums[right] - nums[right - 1]) * (right - left);
res = Math.max(res, right - left + 1);
```

![](./image/2021-07-19-15-54-01.png)

2. 尝试将区间的数向 `nums[right]` 补齐，使用的次数 `sum` **大于** `k`。

这种情况不符合题目题意，需要收缩窗口。

第一步：将 `left` 向 `nums[right]` 补齐时所占的次数返回，即 `sum - <所占部分>`。第二步：将 `left` + 1。

```js
sum -= nums[right] - nums[left];
```

![](./image/2021-07-19-15-52-51.png)

完整JavaScript代码：

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maxFrequency = function(nums, k) {
    nums.sort((a, b) => a - b);
    let res = 1;
    let [left, right, sum] = [0, 1, 0];
    for (; right < nums.length; ++ right) {
        sum += (nums[right] - nums[right-1]) * (right - left);
        while (sum > k) {
            sum -= nums[right] - nums[left];
            left++;
        }
        res = Math.max(res, right - left + 1);
    }
    return res;
};
```

