# 每日一题

## [1838. 最高频元素的频数](https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/)

题目的要求是，在给定的元素内，使数组齐平。例如下图是一个 [1，2，4] 的数组，当 k = 5时补齐的状态。所以答案为 3 。

![](./image/2021-07-19-15-54-38.png)

所以可以使用一个滑动窗口，在这个滑动范围之内，都会尝试去用 `k` 将数组补齐。要使用滑动窗口，必须先让它排个序！此时已经是 (`nlogn`)了。

由于排序数组了，每次枚举在区间内最大的数，会尝试用 `k` 去补齐。在滑动循环内只能由两种情况：（假设滑动区间为 `left ~ right`）

1. 尝试将区间的数向 `nums[right]` 补齐，使用的次数 `sum` **小于等于** `k`。

直接更新当前答案。

```js
// 此刻之前的元素已经与 nums[right - 1] 补齐
// 所以现在只需要把之间的差补齐
nums += (nums[right] - nums[right - 1]) * (right - left);
res = Math.max(res, right - left + 1);
```

![](./image/2021-07-19-15-54-01.png)

2. 尝试将区间的数向 `nums[right]` 补齐，使用的次数 `sum` **大于** `k`。

这种情况不符合题目题意，需要收缩窗口。

第一步：将 `left` 向 `nums[right]` 补齐时所占的次数返回，即 `sum - <所占部分>`。第二步：将 `left` + 1。

```js
sum -= nums[right] - nums[left];
```

![](./image/2021-07-19-15-52-51.png)

完整JavaScript代码：

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maxFrequency = function(nums, k) {
    nums.sort((a, b) => a - b);
    let res = 1;
    let [left, right, sum] = [0, 1, 0];
    for (; right < nums.length; ++ right) {
        sum += (nums[right] - nums[right-1]) * (right - left);
        while (sum > k) {
            sum -= nums[right] - nums[left];
            left++;
        }
        res = Math.max(res, right - left + 1);
    }
    return res;
};
```

## [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

输入两个链表，找出它们的第一个公共节点。

![](./image/2021-07-21-18-19-07.png)

解题思路和动图均来自：[leetcode-腐烂的橘子](https://leetcode-cn.com/u/z1m/)

我们使用两个指针 `node1`，`node2` 分别指向两个链表 `headA`，`headB` 的头结点，然后同时分别逐结点遍历。

当 `node1` 到达链表 `headA` 的末尾时，重新定位到链表 `headB` 的头结点；

当 `node2` 到达链表 `headB` 的末尾时，重新定位到链表 `headA` 的头结点；

这样，当它们相遇时，所指向的结点就是第一个公共结点。

![](./image/GIF-2021-7-21-18-24-17.gif)

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param  {ListNode} headA
 * @param  {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    if (headA == null || headB == null) {
        return null;
    }
    
    let [p1, p2] = [headA, headB];
    while (p1 !== p2) {
        p1 = p1 === null ? headB : p1.next;
        p2 = p2 === null ? headA : p2.next;
    }
    return p1;
};
```