# 动态规划

:::  tip 提示
动态规划是记住你之前做过的事

高考时，在枯燥的刷题过程中，经常会遇到一些不太懂的问题，正常的选择是问老师或者同学，然后把它记到错题本上。过了一段时间，如果又遇到了这样的一个问题，而这个问题和上次遇到的很相像。但是呢，已经记不起来了。这时候可以选择翻之前的错题本，或者是再去问老师和同学
:::

## 闫氏DP分析法

关于其视频讲解教程：[bilibili：闫氏DP分析法，从此再也不怕DP问题！](https://www.bilibili.com/video/BV1X741127ZM?from=search&seid=1472099735408379551)


1. 状态表示

想办法将问题的集合表示出来，赐予该集合一个属性。包括但不限于 `min` `max` `count` `exist`

2. 状态计算

将该集合划分成**多个子集合**，找到一**递推方程**表示他们的关系。类似数论的中[求组合数](http://localhost:8080/algorithm/%5B5%5D%E6%95%B0%E8%AE%BA.html#%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0)的递推公式。

## 01背包问题

问题描述：

有 $N$ 件物品和一个容量式 $M$ 的背包，每件物品只能使用一次。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求将这些物品装入背包，可使这些物品的总体积**不超过背包容量**，且**总价值最大**。

1. 关于状态表示：

设有一数组来代表集合`f[t][a] = s`，它表示的是，前 $t$ 个物品中（这些物品可以装或不装），当背包容量是 $a$ 时，能装下物品的价值之和的最大值（属性） $s$。

2. 关于状态计算：

假设我们正在考虑第 $t$ 个物品，背包容量为 $a$ 的解。它前一个状态有两种表示方式。

* 选择**不装**第 $t$ 个物品后，达到了现在的背包容量 $a$。

`f[t][a] = f[t-1][a]`

* 选择**装**第 $t$ 个物品后，达到了现在的背包容量 $a$。

`f[t][a] = f[t-1][a - v[t]] + w[t]`

注意：`v[t]`是物品`t`的体积，`w[t]`是物品`t`的价值，所以`f[t-1][a - v[t]]`是指前一个集合的状态表示，`+ w[t]`是计算总价值

-----

ACWING OJ：[01背包问题](https://www.acwing.com/problem/content/2/)

```cpp {23}
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
// dp[t][a] = s;表示
// 前t个物品中，当背包容量是a时，能装下物品的价值之和的最大值s。
int dp[N][N]; 

int main(){
    cin >> n >> m;
    for (int i = 1; i <= n; ++ i) {
        cin >> v[i] >> w[i];
    }
    
    for (int t = 1; t <= n; ++ t) {
        for (int a = 1; a <= m; ++ a) {
            dp[t][a] = dp[t-1][a];
            if (a - v[t] >= 0) {
                dp[t][a] = max(dp[t-1][a], dp[t-1][a - v[t]] + w[t]);
            }
        }
    }
    cout << dp[n][m];
    
    return 0;
}
```

## 完全背包问题

问题描述：

有 $N$ 件物品和一个容量式 $M$ 的背包，每件物品**可以使用无限次数**。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求将这些物品装入背包，可使这些物品的总体积**不超过背包容量**，且**总价值最大**。

1. 关于状态划分

设有一数组来代表集合`f[t][a] = s`，它表示的是，前 $t$ 个物品中（这些物品可以装或不装），当背包容量是 $a$ 时，能装下物品的价值之和的最大值（属性） $s$。

2. 关于状态计算：

假设我们正在考虑第 $t$ 个物品，背包容量为 $a$ 的解。它前一个状态有两种表示方式。

> 虽然我不是很想写公式，但我看到视频的时候我直呼妙啊～所以我还是写了一大堆公式

对于正在考虑的物品 $t$，我们可以选择不装，或者装到反正不超过当前假设背包容量 $a$ 就行。

$f(t, a) = max\{f(t-1, a),f(t-1, a - v_t) + w_t, f(t-1, a-2v_t) + 2w_t , .. , f(t-1, a-kv_t) + kw_t\}$

第 $0$ 项选择不装 $t$ 这件物品：$f(t-1, a)$

第 $1$ 项选择装 $t$ 这件物品 $1$ 件：$f(t-1, a - v_t) + w_t$

第 $2$ 项选择装 $t$ 这件物品 $2$ 件：$f(t-1, a-2v_t) + 2w_t$

第 $k$ 项选择装 $t$ 这件物品 $k$ 件：$f(t-1, a-kv_t) + kw_t$

上面那个公式就是说，从这些项中，在不超过背包容量的前提下，选择一个最大值作为 $f(t, a)$ 的值。

如果说我们用代码写的话，这个公式是不是又需要一个 `for` 循环？可惜不用，现在开始使用魔法，将 $a$ 换成 $a - v_i$，代回上面那个式子。

$f(t, a - v_i) = max\{f(t-1, a - v_t), f(t-1, a-2v_t) + w_t , .. , f(t-1, a-kv_t) + (k-1)w_t\}$

对比上面那个式子，可以发现啊，这个 $f(t, a - v_i)$ 和 $f(t, a)$ 某部分长得很像，只是少加了一个 $w_i$，所以最终的递推式子就出来了。

$f(t, a) = max\{f(t-1, a), f(t, a - v_i) + w_i\}$

::: tip 总结
三个式子写在这，可以找不同对比一下

$f(t, a) = max\{f(t-1, a),f(t-1, a - v_t) + w_t, f(t-1, a-2v_t) + 2w_t , .. , f(t-1, a-kv_t) + kw_t\}$

$f(t, a - v_i) = max\{f(t-1, a - v_t), f(t-1, a-2v_t) + w_t , .. , f(t-1, a-kv_t) + (k-1)w_t\}$

$f(t, a) = max\{f(t-1, a), f(t, a - v_i) + w_i\}$
:::

-----

ACWING OJ：[完全背包问题](https://www.acwing.com/problem/content/3/)

```cpp {22}
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
// dp[t][a] = s;表示
// 前t个物品中，当背包容量是a时，能装下物品的价值之和的最大值s。
int dp[N][N];

int main (){
    cin >> n >> m;
    for (int i = 1; i <= n; ++ i) {
        cin >> v[i] >> w[i];
    }
    for (int t = 1; t <= n; ++ t) {
        for (int a = 1; a <= m; ++ a) {
            dp[t][a] = dp[t-1][a];
            if (a - v[t] >= 0) {
                dp[t][a] = max(dp[t-1][a], dp[t][a - v[t]] + w[t]);
            }
        }
    }
    cout << dp[n][m] << endl;
    
    return 0;
}
```

## 合并石子问题

