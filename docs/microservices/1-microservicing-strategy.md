# 1 微服务化策略

## 1.1 微服务架构风格

微服务有两个非常重要的风格：
- 每个服务都拥有自己的数据库
- 系统基于 API 的模块化

### 1.1.1 每个服务都拥有自己的数据库

为了满足在开发和部署上的简易性，每个微服务都对应一个数据库表。这种方式让整个系统以松耦合的方式进行整合。

单体应用的数据访问层和业务层以及 API 路由层分离的方式，随着应用的增多，应用会越来越大，变得难以维护。修改一个 API 的功能有可能会影响其他 API。

而微服务在开发大型应用以及多人协作的场景中有着明显的优势，当某个 API 的表出现死锁等情况时，也不会影响其他API。

### 1.1.2基于API的模块化

微服务的模块化与传统应用的模块化是不同的。对于 Go 语言来说，传统应用的模块化主要是分包。通过包的安装可以调用新的方法、结构体等。而微服务的模块化则是通过 API 进行的，其他服务无法直接调用被封装的方法，只能通过 API 调用。

通过 API 进行模块化可以避免随着应用的增大而导致内部关系复杂。

## 1.2 微服务进程化的重点问题

### 1.2.1 微服务的通信

微服务是分布式系统中的一种，进程间通信（IPC）是整个微服务设计中非常复杂的一部分。
- 通信风格：使用消息通信还是远程调用？需要结合语言来定
- 服务发现：客户端如何发现具体的服务实例请求的地址？（特别是在微服务数量特别多的情况下）
- 可靠性：服务不可用的情况发生时，如何确保服务之间的通信时可靠的？
- 事务性消息：如何将业务上的一个事件，与存放业务数据的数据库表的事务进行集成？
- 外部 API：客户端如何与微服务进行通信？

### 1.2.2 事务管理的一致性

为了保持松耦合，让每个微服务使用自己的独立数据库，带来了很大的难题。

在传统单体应用中可以把对数据库的几步操作放在同一个事务中，现在就不能使用这种方式了。

### 1.2.3 微服务数据查询

服务与数据库一一对应不仅会带来事务管理的问题，实际上还会带来数据查询的问题。

比如要同时展现客户与所购买商品的信息，需要查询 customer 和 product 表：（1）传统的单体应用使用 SQL JOIN 的语句可以很方便地完成。（2）可在微服务中只能操作 API，无法完成 JOIN 操作。有些情况下可以使用API组合的方式，即把需要的API挨个调用，然后把结果聚合。不过，更多时候会使用命令查询职责分离（CQRS）的方式。

### 1.2.4 微服务部署

常用的有如下三种：

- 单主机多服务模式

把多个服务部署在同一台主机或虚拟机上，一般一个服务对应一个端口。

这种方式可以借助 Web 服务器进行优化，比如 Apache 或 Nginx 服务器，通过端口转发完成该工作。这样部署简单，容易理解。但运维团队需要了解部署的细节，当机器重启时，因为有多个服务，重启会变得很复杂。

- 单主机单服务模式

该模式下每个服务器或虚拟机上运行单独的服务，一般是一个虚拟机运行一个服务实例。这样环境隔离非常好，运维相对容易。但 CPU 和内存都是隔离开的，无法动态分配，导致资源利用率低。

- 单容器单服务模式（应用非常广的模式）

一个 Docker 一个服务，容器既有隔离性，又可以更好地分配资源，缺点是容器镜像管理会比较复杂。

### 1.2.5 微服务生产环境监控

试想有大量的API部署在几台服务器上，想要了解当前的访问压力如何、有没有报错以及错误的跟进和诊断，都变得及其困难。

微服务的生产环境必须要有足够优秀的监控手段，其中应该包括如下服务：
- API 状态：**返回 API 的健康状态**
- 日志集中处理：**把各个服务器上的日志集中到一台服务器**，然后提高日志搜索性能、增加预警等功能。
- 请求追踪：因为微服务是分布式的，所以请求的跟踪也有其特点，**要为每一个请求分配一个ID**，方便在各个微服务之间跟踪请求。
- 异常跟踪：每个外部的访问可能触发多个API，而这当中很可能出现异常；多次同样的请求也可能触发相同的异常。所以需要**提供统一的异常接收和去重并记录的服务**。
- 运行指标：**提供各种应用运行的指标数据**，比如访问次数、登陆次数、供运维人员使用。
- 行为日志：**记录用户的行为**。

### 1.2.6 微服务的自动化测试

微服务的单个服务测试比传统应用架构更为简单，但多个服务之间的协同测试变得极为困难。以下测试模式都是值得思考和关注的。
- 消费端的功能测试：验证服务能否完全满足期望的功能
- 消费端的契约测试：验证客户端能否与服务端正常通信
- 服务端的组件测试：在隔离的环境中测试服务

## 1.3 微服务的拆分

### 1.3.1 拆分的指导原则

拆分的策略有几种，但拆分的指导原则只有两个：单一职责和闭包原则。

单一职责让微服务足够单一，但一到修改一个微服务应该有且仅有一个理由。如果有多个理由去修改一个微服务，意味着该微服务承担了太多的职责。具体的说，微服务应该满足小、内聚、职责单一的特点，比如销售订单的获取、销售订单的签署。

闭包原则：当需要一个微服务时，所有依赖都在这个微服务的组件内，不需要修改其他微服务。

### 1.3.2 依据业务能力拆分

一般情况下，业务能力都是逐步细分的。比如库存管理，如果是一个家电企业，可以继续分为原材料库存、半成品库存和成品库存。成品库存又可能分为未售库存和已售未提库存。最终可以根据细分的业务能力进行服务的定义。

但这个策略严重依赖架构师的经验和业务知识，在拆分过程中的决策都是比较主观的。

### 1.3.3 依据领域驱动设计拆分

驱动领域设计（Domain-Driven Design，简称 DDD）。

企业的销售部门、风控部门、财务部门、运营部门同时关心客户、要处理这个例子，比较容易想到两个方案。

一种方案是使用高内聚表的模式，把所有客户相关的字段都封装在一个 customer 表内。这样所有部门的相关操作都是针对这个表进行的，但这严重违反了微服务闭包的指导原则，因为多个服务之间依赖关系过大。

另一种方案是把 customer 的相关操作封装为一个服务，然后所有客户相关的服务都通过调用该服务来完成，其他服务不再直接操作 customer 表。这样会让客户服务的职责不再单一，它包含客户维护、信用评级和风控、财务付款等多个职责。其次该服务不是直接给客户端使用的，而是为其他服务所调用。这种一对多关联性仍然会为维护造成麻烦。

如果采用 DDD 原则，销售部门、风控部门和财务部门关心的客户字段分别如下。

- 销售部门：客户名称、地址、联系电话
- 风控部门：客户名称、信用额度、法院判决书数、最后股权变动日期
- 财务部门：税号、付款额度、应收款

这样每个领域模型的信息拼起来就是客户完整信息。但是也会带来一些跨服务数据一致性的问题：假如风控部门修改了客户的信用额度为负值，此时销售部门就不应该继续向该客户销售产品。但销售部门无法从它们所关心的客户字段里得到这个信息，导致两个部门对一个客户的判断出现了偏差。

领域模型有可能会影响到用户体验，比如当需要向用户显示所有客户的字段信息时，需要在几个领域模型进行多次调用，这与 API Gateway 有关。

### 1.3.4 服务 API 的定义

前面介绍了拆分的两个原则和两种策略。事实上，前面拆分得到的未必是对应的 API，准确的说，前面的拆分结果是”操作“。

我们要基于这些”操作“列表对具体的服务列表进行定义。要定义的 API 有两类：
- 供客户端调用的 API
- 供其他服务调用的 API

”操作“与 API 之间不是一一对应的。有两方面原因：
- 有些服务可能并未在”操作“中列出，比如维持数据统一性的服务。
- 有些服务在领域模型属于风控，做成服务有可能属于销售。

这有点类似于分层架构中的数据访问层和业务操作层的关系。