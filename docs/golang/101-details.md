# 其他

### 变量

`struct{}` 和 `[]int` 类型的大小是 0，他们有可能有相同的地址

对于在**包一级声明的变量**来说，他们的声明周期和整个程序的运行周期是一致的。**局部变量**的声明周期是动态的，每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止。然后局部变量的存储空间才可能被回收。函数的参数和返回值都是局部变量，它们在函数每次被调用的时候创建。

### GC

Go 语言的自动垃圾收集器基本实现思路：从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，说明变量不可达，代表它的存在不会影响程序后续的计算结果。编译器会自动选择在栈上还是在堆上分配局部变量的储存空间，而且不由 `var` 或 `new` 声明变量的方式决定

### 元组赋值

```go
a, b = b, a
```

在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。

### 包的初始化

包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序一次初始化

```go
var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
```

如果包中含有多个.go源文件，它们将**按照发给编译器的顺序**进行初始化。Go语言的构建工具首先**会将.go文件根据文件名排序**然后**依次调用编译器编译**。

某些表格数据初始化并不是一个简单的赋值过程，在这种情况下，可以使用 init 初始化函数简化初始化工作，每个文件都可以包含多个 init 初始化函数。

```go
func init() { /* ... */}
func init() { /* ... */}
func init() { /* ... */}
```

每个包在解决依赖的前提下，以导入声明的顺序初始化，**每个包只会被初始化一次**。如果一个 b 包导入了 a，那么在 b 包初始化的时候可以认为 a 包必然已经初始化过了。初始化工作是自下而上进行的，main 包最后才被初始化。以这种方式，可以确保 main 函数执行之前，所有依赖的包都已经完成初始化的工作了。  

### 作用域

当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。
* 如果查找失败，则报告“未声明的名字”这样的错误。
* 如果该名字在内部和外部的块分别声明过，则内部的块声明首先被找到。（在这种情况下，内部的声明屏蔽了外部的声明，让外部的声明无法被访问）

### 运算

在 Go 语言中，% 取模的运算符的符号**和被取模数的符号总是一致**的，因此 -5%3 和 -5%-3 结果都是 -2。

除法运算符 / 的结果依赖于操作数是否全为整数。5.0/4.0 的结果是 1.25，但是 5/4 的结果是 1。

运算的结果，如果需要更多 bit 位才能正确表示的话，就说明计算结果是移除了。超出的高位的bit位部分将被丢弃。如果原始的数值是有符号类型，而且最左边的bit位是1的话，那么最终结果可能是负的。

```go
var u uint8 = 255
println(u, u+1, u*u) // 255 0 1

var i int8 = 127
println(i, i+1, i*i) // 127 -128 1
```

### string

两个字符串 A 和 B 使用 + 号进行拼接，会返回一个新字符串 C。如果连接涉及的数据量很大，代价高昂。

:::tip
这里应该补充系统性的性能测评
:::

因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的。

```go
s[0] = 'L' // compile error: cannot assign to s[0]
```

不变性意味着，如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串 `s` 和对应的子字符串切片 `s[7:]` 的操作可以安全地共享相同的内存，因此字符串切片的代价也是低廉的。在这两种情况下都没有必要分配新的内存。

![](./image/2022-01-31-12-42-38.png)

一个字符串是包含只读字节的数据，一旦创建，是不可变的。相比之下，一个 []byte 的元素可以自由地修改，一般可以将 string 转成 []byte。

一个 `[]byte(s)` 转换是分配一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。

## map

key 可以是任意类型，但其值必须能用 == 运算符比较。

map 的迭代顺序并不确定，顺序随机。