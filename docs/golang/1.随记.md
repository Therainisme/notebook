# 随记

## 发送 POST 请求

```go
func main() {
    // 一个请求体 (body) 的 json 格式
    // 一般不用 string， 而用 []byte
    // 如果是 string 通过 []byte(string) 转换即可
    var body []byte = "xxxxx" 

    // 想办法创建一个 Reader
    reader := bytes.NewReader(body)

    // 创建一个请求，这个请求可以加入 Header，如果没有 body 则写 nil
    request, err := http.NewRequest("POST", "http://xxxx", reader)
    reqeust.Header.Set("Content-Type", "application/json")

    // response.Body 是一个 Reader 子类，记得关闭
    client := &http.Client{}
    response, err := client.Do(request)
    defer response.Body.Close()

    // ioutil.ReadAll 专门读 Reader 返回数据的 []byte 形式
    body, err := ioutil.ReadAll(response.Body)
}
```

## JSON 数据对象的处理

如果想把一个数据对象转换成 JSON 格式，有 `func json.Marshal(v interface{}) ([]byte, error)`。

看到 `v interface{}` 不难得知，只要给予这个数据对象的地址，那么都能获取对应的 `[]byte` 形式

```go
func main() {
    // 如果有对象的话，直接 &
    // 获得 []byte 形式的数据
    data, err := json.Marshal(&object)

    // 把它变成肉眼可见的 JSON
    json := string(data)
}
```

把 JSON 转成数据对象的话，不像　JavaScript 方便

他有一个 `func json.Unmarshal(data []byte, v interface{}) error`

必须先把数据结构体定义好，并配上注解才能比较聪明的填充进去

```go
type GroupMessageEvent struct {
	PostType    string `json:"post_type"`
	MessageType string `json:"message_type"`
	GroupId     int    `json:"group_id"`
	SenderId    int    `json:"user_id"`
	Message     string `json:"message"`
	Sender      Sender `json:"sender"`
}

func main() {
    var event = &GroupMessageEvent{}
	body, _ := ioutil.ReadAll(request.Body)
	json.Unmarshal(body, &event)
}
```

## 通过 GET 下载图片到本地

这里有一个把 `Reader` 和 `Writer` 连起来的东西。

`func Copy(dst Writer, src Reader) (written int64, err error)`

将 `src` 的数据拷贝到 `dst`，直到在 `src` 上到达EOF或发生错误。返回拷贝的字节数和遇到的第一个错误。

```go
func Download() {
    // 第一步，想办法获取 Reader (response.Body : Reader)
    response, err := http.Get(imgUrl)
	if err != nil {
		fmt.Println("A error occurred!")
		return
	}
	defer response.Body.Close()

    // bufio 包实现了有缓冲的 I/O
    // 总的来说，能存就存，bufio.newReader 默认是 4096
    // 不能存就直接往容器里塞
    reader := bufio.NewReaderSize(res.Body, 32*1024)

    // 创建那个文件对象，路径
    file, _ := os.Create("xxxx.xxx")
    defer file.Close()

	// 获得文件的 Writer 对象
	writer := bufio.NewWriter(file)

    // 开始写入文件
    written, _ := io.Copy(writer, reader)
}
```

## 自定义对象排序

需要自己实现一个 `sort.interface` 的接口

```go
type Gamer struct {
	Sender
	Score int
}

type GamerSlice []*Gamer

// 获取 slice 的长度
func (gamerSlice GamerSlice) Len() int {
	return len(gamerSlice)
}

// 交换 slice 其中两个
func (gamerSlice GamerSlice) Swap(a, b int) {
	gamerSlice[a], gamerSlice[b] = gamerSlice[b], gamerSlice[a]
}

// 这个决定了是升序排序还是降序排序
// 而且决定着比较的内容是什么
func (gamerSlice GamerSlice) Less(i, j int) bool {
	return gamerSlice[i].Score > gamerSlice[j].Score
}

func main() {
    // 真正需要排序的时候 (rankSlice : []*Gamer)
    sort.Sort(GamerSlice(rankSlice))
}
```

## 服务器监听

如果我没有猜错的话，这个 `writer` 可以用来返回数据给请求发出者，这个 `request` 也应该拥有此次请求的所有信息。嗯，猜的。

```go
func handle(writer http.ResponseWriter, request *http.Request) {
	var event = &GroupMessageEvent{}
	body, _ := ioutil.ReadAll(request.Body)
	json.Unmarshal(body, &event)
	if event.PostType == "message" && event.MessageType == "group" {
		Dispatch(event)
	}
}

func Run() {
	http.HandleFunc("/", handle)
	http.ListenAndServe(":5701", nil)
}
```